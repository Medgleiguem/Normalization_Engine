"""
SQL script generator - creates MySQL scripts with best practices
"""
from typing import List
from app.models.table_model import Table
from app.models.analysis_result import AnalysisResult

class SQLGenerator:
    """Generate MySQL scripts from normalized tables"""
    
    def __init__(self, analysis_result: AnalysisResult):
        self.analysis_result = analysis_result
        self.final_tables = analysis_result.final_tables
    
    def generate_script(self) -> str:
        """Generate complete MySQL script"""
        script_parts = []
        
        # Header comment
        script_parts.append(self._generate_header())
        
        # Database creation
        script_parts.append(self._generate_database_creation())
        
        # Table creation statements
        for table in self.final_tables:
            script_parts.append(self._generate_create_table(table))
        
        # Foreign key constraints (added after all tables are created)
        script_parts.append(self._generate_foreign_keys())
        
        # Indexes for optimization
        script_parts.append(self._generate_indexes())
        
        # Footer comment
        script_parts.append(self._generate_footer())
        
        return '\n\n'.join(script_parts)
    
    def _generate_header(self) -> str:
        """Generate script header with metadata"""
        return """-- ============================================================================
-- Database Normalization Script
-- Generated by Database Normalization Analysis Tool
-- ============================================================================
--
-- This script creates a normalized database schema based on the analysis
-- of the uploaded Excel file. The schema has been normalized to ensure:
--   - Data integrity and consistency
--   - Elimination of redundancy
--   - Optimal query performance
--   - Compliance with normal forms (1NF through 5NF)
--
-- Original Table: {}
-- Final Normal Form Achieved: {}
-- Number of Tables Created: {}
--
-- ============================================================================
""".format(
            self.analysis_result.original_table.name,
            self.analysis_result.normalization_steps[-1].to_nf.value if self.analysis_result.normalization_steps else "N/A",
            len(self.final_tables)
        )
    
    def _generate_database_creation(self) -> str:
        """Generate database creation statement"""
        db_name = f"{self.analysis_result.original_table.name}_normalized"
        return f"""-- Create database
CREATE DATABASE IF NOT EXISTS `{db_name}`
    CHARACTER SET utf8mb4
    COLLATE utf8mb4_unicode_ci;

USE `{db_name}`;

-- Set SQL mode for strict data validation
SET SQL_MODE = 'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
"""
    
    def _generate_create_table(self, table: Table) -> str:
        """Generate CREATE TABLE statement for a single table"""
        lines = []
        
        # Table comment explaining its purpose
        purpose = self._get_table_purpose(table)
        lines.append(f"-- {purpose}")
        lines.append(f"CREATE TABLE IF NOT EXISTS `{table.name}` (")
        
        # Column definitions
        col_defs = []
        for col in table.columns:
            col_defs.append(f"    {col.to_sql()}")
        
        # Primary key
        if table.primary_key:
            pk_cols = ', '.join(f"`{col}`" for col in sorted(table.primary_key))
            col_defs.append(f"    PRIMARY KEY ({pk_cols})")
        
        lines.append(',\n'.join(col_defs))
        lines.append(") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;")
        
        # Add table comment
        lines.append(f"-- Table '{table.name}' stores {purpose.lower()}")
        
        return '\n'.join(lines)
    
    def _generate_foreign_keys(self) -> str:
        """Generate ALTER TABLE statements for foreign keys"""
        lines = ["-- Add foreign key constraints for referential integrity"]
        
        for table in self.final_tables:
            if table.foreign_keys:
                for fk_col, (ref_table, ref_col) in table.foreign_keys.items():
                    fk_name = f"fk_{table.name}_{fk_col}"
                    lines.append(f"""ALTER TABLE `{table.name}`
    ADD CONSTRAINT `{fk_name}`
    FOREIGN KEY (`{fk_col}`)
    REFERENCES `{ref_table}` (`{ref_col}`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
-- Foreign key '{fk_name}' ensures referential integrity between {table.name} and {ref_table}""")
        
        return '\n\n'.join(lines) if len(lines) > 1 else "-- No foreign key constraints needed"
    
    def _generate_indexes(self) -> str:
        """Generate CREATE INDEX statements for optimization"""
        lines = ["-- Create indexes for query optimization"]
        
        for table in self.final_tables:
            # Index foreign key columns
            if table.foreign_keys:
                for fk_col in table.foreign_keys.keys():
                    if fk_col not in table.primary_key:
                        idx_name = f"idx_{table.name}_{fk_col}"
                        lines.append(f"""CREATE INDEX `{idx_name}` ON `{table.name}` (`{fk_col}`);
-- Index on '{fk_col}' improves JOIN performance""")
            
            # Index columns that appear in functional dependencies
            for fd in table.functional_dependencies:
                for col in fd.determinant:
                    if col not in table.primary_key and col not in table.foreign_keys:
                        idx_name = f"idx_{table.name}_{col}"
                        lines.append(f"""CREATE INDEX `{idx_name}` ON `{table.name}` (`{col}`);
-- Index on '{col}' improves query performance for searches and joins""")
        
        return '\n\n'.join(lines) if len(lines) > 1 else "-- No additional indexes needed"
    
    def _generate_footer(self) -> str:
        """Generate script footer"""
        return """-- ============================================================================
-- End of Database Normalization Script
-- ============================================================================
--
-- BEST PRACTICES IMPLEMENTED:
--   ✓ InnoDB engine for ACID compliance and foreign key support
--   ✓ UTF8MB4 character set for full Unicode support (including emojis)
--   ✓ Proper primary keys for all tables
--   ✓ Foreign key constraints with CASCADE for referential integrity
--   ✓ Indexes on foreign keys and frequently queried columns
--   ✓ Strict SQL mode for data validation
--   ✓ Descriptive naming conventions
--   ✓ Comprehensive comments for maintainability
--
-- NORMALIZATION BENEFITS:
--   ✓ Eliminated data redundancy
--   ✓ Improved data integrity
--   ✓ Reduced update anomalies
--   ✓ Optimized storage efficiency
--   ✓ Enhanced query performance
--
-- ============================================================================
"""
    
    def _get_table_purpose(self, table: Table) -> str:
        """Generate a description of the table's purpose"""
        # Try to infer purpose from table name and structure
        if 'user' in table.name.lower():
            return "User information and authentication data"
        elif 'order' in table.name.lower():
            return "Order transactions and details"
        elif 'product' in table.name.lower():
            return "Product catalog and inventory"
        elif 'detail' in table.name.lower():
            return "Detailed information extracted during normalization"
        else:
            return f"Data for {table.name.replace('_', ' ')}"
